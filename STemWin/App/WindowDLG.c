/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.44                          *
*        Compiled Nov 10 2017, 08:53:57                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "gui_resources.h"
#include "main.h"
// USER END

#include "DIALOG.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0 (GUI_ID_USER + 0x00)
#define ID_BUTTON_0 (GUI_ID_USER + 0x01)
#define ID_BUTTON_1 (GUI_ID_USER + 0x02)
#define ID_BUTTON_2 (GUI_ID_USER + 0x03)
#define ID_BUTTON_3 (GUI_ID_USER + 0x04)
#define ID_BUTTON_4 (GUI_ID_USER + 0x05)
#define ID_BUTTON_5 (GUI_ID_USER + 0x06)
#define ID_BUTTON_6 (GUI_ID_USER + 0x07)
#define ID_BUTTON_7 (GUI_ID_USER + 0x08)
#define ID_TEXT_0 (GUI_ID_USER + 0x09)


// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
static void rainbowEffect(WM_HWIN hItem);
static void TimerCallbackHandler(WM_MESSAGE *pMsg);

extern GUI_HWIN hClockWindow;
extern GUI_HWIN hCurrentWindow;
extern GUI_HWIN hDesktop;
extern GUI_HWIN hHomeWindow;
extern GUI_HWIN hAlarmWindow;
extern GUI_HWIN hTaskBar;
extern GUI_HWIN hAudioWindow;
extern GUI_HWIN hFreqAnalysisWindow;
extern GUI_HWIN hMusicWindow;


extern void MoveToClockWindow(WM_HWIN hWin);
extern void MoveToAlarmWindow(WM_HWIN hWin);
extern void MoveToAudioWindow(WM_HWIN hWin);
extern void MoveToFreqAnalysisWindow(WM_HWIN hWin);
extern void MoveToMusicWindow(WM_HWIN hWin);

static uint16_t Special_Effect = 0;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 0, 0, 480, 242, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "", ID_BUTTON_0, 40, 10, 70, 70, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "", ID_BUTTON_1, 150, 10, 70, 70, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "", ID_BUTTON_2, 260, 10, 70, 70, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "", ID_BUTTON_3, 370, 10, 70, 70, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "", ID_BUTTON_4, 40, 130, 70, 70, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "", ID_BUTTON_5, 150, 130, 70, 70, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "", ID_BUTTON_6, 260, 130, 70, 70, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "", ID_BUTTON_7, 370, 130, 70, 70, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "Text", ID_TEXT_0, 140, 222, 200, 20, 0, 0x64, 0 },
  // USER START (Optionally insert additional widgets)
  
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
    TEXT_SetFont(hItem, GUI_FONT_16B_ASCII);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "Group4  @MianXu @WangHe");
    TEXT_SetTextColor(hItem, GUI_MAKE_COLOR(0x00C08000));
    // USER START (Optionally insert additional code for further widget initialization)
    hItem = pMsg->hWin;
    WINDOW_SetBkColor(hItem, GUI_MAKE_COLOR(0x00AEAEAE));

    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
    BUTTON_SetBitmap(hItem, 0, &bmClock);
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
    BUTTON_SetBitmap(hItem, 0, &bmAlarm);
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);
    BUTTON_SetBitmap(hItem, 0, &bmMic);
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_3);
    BUTTON_SetBitmap(hItem, 0, &bmFreq);
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_4);
    BUTTON_SetBitmap(hItem, 0, &bmMusic);
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_7);
    BUTTON_SetBitmap(hItem, 0, &bmAlert);
    #ifdef CMSIS_V1
    WM_CreateTimer(pMsg->hWin, 0, 100, 0);
    #endif

    #ifdef CMSIS_V2
    WM_CreateTimer(pMsg->hWin, 0, 200000000, 0);
    #endif
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by ''
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        WM_BringToTop(hCurrentWindow = hClockWindow);
        MoveToClockWindow(hClockWindow);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_1: // Notifications sent by ''
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        WM_BringToTop(hCurrentWindow = hAlarmWindow);
        MoveToAlarmWindow(hCurrentWindow);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_2: // Notifications sent by ''
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        //WM_BringToBottom(hCurrentWindow);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        WM_BringToTop(hCurrentWindow = hAudioWindow);
        MoveToAudioWindow(hCurrentWindow);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_3: // Notifications sent by ''
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        WM_BringToTop(hCurrentWindow = hFreqAnalysisWindow);
        MoveToFreqAnalysisWindow(hCurrentWindow);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_4: // Notifications sent by ''
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        WM_BringToTop(hCurrentWindow = hMusicWindow);
        MoveToMusicWindow(hMusicWindow);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_5: // Notifications sent by ''
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_6: // Notifications sent by ''
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_7: // Notifications sent by ''
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        Special_Effect = !Special_Effect;
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  case WM_TIMER:
    TimerCallbackHandler(pMsg);
    break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/
WM_HWIN CreateWindow(void);
WM_HWIN CreateWindow(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)
WM_HWIN CreateDesktop(void) {
  WM_HWIN hWin = WM_CreateWindow(0, 30, 480, 242, WM_CF_SHOW, 0, 0);

  return hWin;
}



static void TimerCallbackHandler(WM_MESSAGE *pMsg)
{
  static uint16_t count = 100, i;
  static int      xi[8] = {40, 150, 260, 370, 40, 150, 260, 370}, 
                  yi[8] = {10, 10, 10, 10, 130, 130, 130, 130}, 
                  mxi[8] = {5, -4, 7, -5, -4, -7, 5, 4}, 
                  myi[8] = {6, -5, -5, -6, 3, -3, 7, -6};
  static int buttonIDs[] = {ID_BUTTON_0, ID_BUTTON_1, ID_BUTTON_2, ID_BUTTON_3, ID_BUTTON_4, ID_BUTTON_5, ID_BUTTON_6, ID_BUTTON_7};

  count += 50;
  if(count > 1000)
  {
    rainbowEffect(WM_GetDialogItem(pMsg->hWin, ID_TEXT_0));
    count = 0;
  }


  if(Special_Effect && hCurrentWindow == hHomeWindow)
  {
    for(i = 0; i < 8; i++)
    {
      xi[i] = WM_GetWindowOrgX(WM_GetDialogItem(pMsg->hWin, buttonIDs[i])); 
      yi[i] = WM_GetWindowOrgY(WM_GetDialogItem(pMsg->hWin, buttonIDs[i]));

      if(xi[i] > 410 || xi[i] < 0)
        mxi[i] = -mxi[i];
      if(yi[i] > 202 || yi[i] < 30)
        myi[i] = -myi[i];

      WM_MoveWindow(WM_GetDialogItem(pMsg->hWin, buttonIDs[i]), mxi[i], myi[i]);
    }
  }


#ifdef CMSIS_V1
  WM_RestartTimer(pMsg->Data.v, 50);
#endif
#ifdef CMSIS_V2
  WM_RestartTimer(pMsg->Data.v, 20000000);
#endif
}


/**
 * @brief  Apply rainbow effect to object `hItem`
 * @param  WM_HWIN hItem
 * @param  int second
 * @retval None
 */
static void rainbowEffect(WM_HWIN hItem)
{
  static unsigned short second = 0;
	switch (second++ % 7)
	{
	case 0:
		TEXT_SetTextColor(hItem, GUI_RED);
		break;
	case 1:
		TEXT_SetTextColor(hItem, GUI_ORANGE);
		break;
	case 2:
		TEXT_SetTextColor(hItem, GUI_YELLOW);
		break;
	case 3:
		TEXT_SetTextColor(hItem, GUI_GREEN);
		break;
	case 4:
		TEXT_SetTextColor(hItem, GUI_CYAN);
		break;
	case 5:
		TEXT_SetTextColor(hItem, GUI_BLUE);
		break;
	case 6:
		TEXT_SetTextColor(hItem, GUI_MAGENTA);
		break;
	};
}
// USER END

/*************************** End of file ****************************/
